diff -uNr cs550-17s-proj1-base/Makefile cs550-17s-proj1-working/Makefile
--- cs550-17s-proj1-base/Makefile	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/Makefile	2017-02-18 23:50:09.507545410 -0500
@@ -51,7 +51,7 @@
 endif
 
 # If the makefile can't find QEMU, specify its path here
-# QEMU = qemu-system-i386
+QEMU = ~zhangy/fs/bin/qemu-system-i386
 
 # Try to infer the correct QEMU
 ifndef QEMU
diff -uNr cs550-17s-proj1-base/proc.c cs550-17s-proj1-working/proc.c
--- cs550-17s-proj1-base/proc.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/proc.c	2017-02-23 18:19:49.161469180 -0500
@@ -7,20 +7,24 @@
 #include "proc.h"
 #include "spinlock.h"
 
+int policy = 0;
+int myGlobal;
 struct {
   struct spinlock lock;
   struct proc proc[NPROC];
 } ptable;
 
+//int policy;
 static struct proc *initproc;
-
+int STRIDE_TOTAL_TICKETS = 100;
 int nextpid = 1;
-
+int max = 2000;
 int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
 
 extern void forkret(void);
 extern void trapret(void);
 
+
 static void wakeup1(void *chan);
 
 void
@@ -125,14 +129,17 @@
   return 0;
 }
 
+
 // Create a new process copying p as the parent.
 // Sets up stack to return as if from system call.
 // Caller must set state of returned proc to RUNNABLE.
+
 int
 fork(void)
 {
   int i, pid;
   struct proc *np;
+  struct proc *p;
 
   // Allocate process.
   if((np = allocproc()) == 0)
@@ -151,6 +158,7 @@
 
   // Clear %eax so that fork returns 0 in the child.
   np->tf->eax = 0;
+ 
 
   for(i = 0; i < NOFILE; i++)
     if(proc->ofile[i])
@@ -160,12 +168,44 @@
   safestrcpy(np->name, proc->name, sizeof(proc->name));
  
   pid = np->pid;
+  np->pass = 0;
 
   // lock to force the compiler to emit the np->state write last.
   acquire(&ptable.lock);
   np->state = RUNNABLE;
   release(&ptable.lock);
-  
+
+      acquire(&ptable.lock);
+	int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+   //   cprintf("\n\ntotal active process at this point: %d\n\n", count);
+
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+	   {
+                p->tickets = (STRIDE_TOTAL_TICKETS/count);
+		if(p->tickets != 0)
+		p->strides = (STRIDE_TOTAL_TICKETS/p->tickets);
+                p->pass = 0;   //other changes
+           }
+  	else{
+	    p->tickets = 0;
+            p->strides = 0;}
+        //    cprintf("\nstate: %d Total number of tickets for %d, %d strides: %d pass: %d\n",p->state,p->pid,p->tickets, p->strides, p->pass);
+       }
+
+        release(&ptable.lock);
+        //cprintf("\nTotal number of active processes: %d\n",count);
+
+	if(myGlobal == 1)
+	  {
+		proc->state = RUNNING;
+		yield();
+  	  }
+
   return pid;
 }
 
@@ -210,6 +250,31 @@
 
   // Jump into the scheduler, never to return.
   proc->state = ZOMBIE;
+
+
+      int count = 0;
+      struct proc *q;
+      for(q = ptable.proc; q < &ptable.proc[NPROC]; q++){
+         if(q->state == RUNNABLE || q->state == RUNNING)
+            count++;
+
+       }
+
+      for(q = ptable.proc; q < &ptable.proc[NPROC]; q++){
+           if(q->state == RUNNABLE || q->state == RUNNING)
+            {
+                q->tickets = (STRIDE_TOTAL_TICKETS/count);
+                if(q->tickets != 0)
+                q->strides = (STRIDE_TOTAL_TICKETS/q->tickets);
+                q->pass = 0;   //other changes
+            }
+        else{
+              q->tickets = 0;
+              q->strides = 0;
+              q->pass = 0;
+            }
+        }
+
   sched();
   panic("zombie exit");
 }
@@ -268,43 +333,106 @@
 void
 scheduler(void)
 {
-  struct proc *p;
-  int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
-
-  for(;;){
-    // Enable interrupts on this processor.
-    sti();
-
-    // Loop over process table looking for process to run.
-    acquire(&ptable.lock);
-    ran = 0;
-    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
-      if(p->state != RUNNABLE)
-        continue;
-
-      ran = 1;
-      
-      // Switch to chosen process.  It is the process's job
-      // to release ptable.lock and then reacquire it
-      // before jumping back to us.
-      proc = p;
-      switchuvm(p);
-      p->state = RUNNING;
-      swtch(&cpu->scheduler, proc->context);
-      switchkvm();
-
-      // Process is done running for now.
-      // It should have changed its p->state before coming back.
-      proc = 0;
-    }
-    release(&ptable.lock);
+    struct proc *p;
+    struct proc *minProc;
+   // double z;
+    int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
+
+    for(;;)
+    {
+        // Enable interrupts on this processor.
+        sti();
+
+        // Loop over process table looking for process to run.
+        acquire(&ptable.lock);
+
+        if(policy == 1)
+        {
+            int  minpass = max;
+            //find the min pass
+            ran = 0;
+
+/*
+struct proc *q;
+for(q = ptable.proc; q < &ptable.proc[NPROC]; q++)
+{
+        if(q->pid == 3)
+       cprintf("\n%d:%d\n", q->pid,q->pass);
+	if(q->pid == 4)
+        cprintf("%d:%d\n", q->pid, q->pass);
+       if(q->pid == 5)
+        cprintf("%d:%d\n", q->pid, q->pass);
+       if(q->pid == 6)
+        cprintf("%d:%d\n", q->pid, q->pass);
+}
+*/
+
+            for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+            {
+                if(p->state != RUNNABLE)
+		  continue;
+		if(p->pass < minpass)
+			{
+			 minpass = p->pass;
+			 minProc= p;
+			}
+            }
+         if(minpass >= max)
+           {
+                for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+                p->pass = 0; 
+           }
+            // obtain the process to be scheduled
+                p= minProc;
+                p->pass = p->pass + p->strides;
+                ran = 1;
+                proc = p;
+                switchuvm(p);
+                p->state = RUNNING;
+                swtch(&cpu->scheduler, proc->context);
+                switchkvm();
+
+                // Process is done running for now.
+                // It should have changed its p->state before coming back.
+                proc = 0;
+        }
+        else
+        {
+            ran = 0;
+            for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+            {
+                if(p->state != RUNNABLE)
+                    continue;
+
+                ran = 1;
+
+                // Switch to chosen process.  It is the process's job
+                // to release ptable.lock and then reacquire it
+                // before jumping back to us.
+       //   cprintf("chosen process:%d",p->pid);
+                proc = p;
+                switchuvm(p);
+                p->state = RUNNING;
+                swtch(&cpu->scheduler, proc->context);
+                switchkvm();
+
+                // Process is done running for now.
+                // It should have changed its p->state before coming back.
+                proc = 0;
+            }
+        }
+        release(&ptable.lock);
 
-    if (ran == 0){
-        halt();
+        if (ran == 0)
+        {
+            halt();
+        }
+//for(z=0;z<10000000;z++)
+//{if(z>100) z = z - 0.5;}
     }
-  }
 }
 
+
 // Enter scheduler.  Must hold only ptable.lock
 // and have changed proc->state.
 void
@@ -479,3 +607,27 @@
     cprintf("\n");
   }
 }
+
+int transfer_tickets(int pid, int tickets, struct proc *calle)
+{
+ if(tickets < 0) 
+   return -1;
+ if(tickets > (calle->tickets - 1))
+   return -2;
+   struct proc *p;
+   acquire(&ptable.lock);
+   for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+   {
+       if(p->pid == pid)
+       {
+         p->tickets += tickets;
+	 calle->tickets -= tickets;
+	 p->strides = (STRIDE_TOTAL_TICKETS/p->tickets);
+         calle->strides = (STRIDE_TOTAL_TICKETS/calle->tickets);
+	 release(&ptable.lock);
+         return calle->tickets;
+       }
+   } 
+   release(&ptable.lock);
+   return -3;
+}
diff -uNr cs550-17s-proj1-base/proc.c.save cs550-17s-proj1-working/proc.c.save
--- cs550-17s-proj1-base/proc.c.save	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/proc.c.save	2017-02-21 20:35:49.624952834 -0500
@@ -0,0 +1,553 @@
+#include <math.h>
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+#include <math.h>
+
+int myGlobal;
+
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+int policy;
+static struct proc *initproc;
+int STRIDE_TOTAL_TICKETS = 100;
+int nextpid = 1;
+
+int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
+
+extern void forkret(void);
+extern void trapret(void);
+
+static void wakeup1(void *chan);
+
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  release(&ptable.lock);
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+  
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
+  
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
+
+  return p;
+}
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+  p = allocproc();
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+}
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint sz;
+  
+  sz = proc->sz;
+  if(n > 0){
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  proc->sz = sz;
+  switchuvm(proc);
+  return 0;
+}
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+ 
+  pid = np->pid;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
+  release(&ptable.lock);
+
+      acquire(&ptable.lock);
+	int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+             cprintf("\nTotal number of tickets: %d\n",p->tickets);
+       }
+
+      release(&ptable.lock);
+        //cprintf("\nTotal number of active processes: %d\n",count);
+
+	if(myGlobal == 1)
+	  {
+		proc->state = RUNNING;
+		yield();
+  	  }
+
+  return pid;
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+  struct proc *p;
+  int fd;
+
+  if(proc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(proc->ofile[fd]){
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(proc->cwd);
+  end_op();
+  proc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+
+cprintf("\n\nAfter Exit\n");
+      acquire(&ptable.lock);
+        int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+             cprintf("\nTotal number of tickets: %d\n",p->tickets);
+       }
+
+      release(&ptable.lock);
+
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == proc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  proc->state =cprintf("\n\nAfter Exit\n");
+      acquire(&ptable.lock);
+        int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+             cprintf("\nTotal number of tickets: %d\n",p->tickets);
+   
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+  struct proc *p;
+  int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
+
+	if(policy)
+	cprintf("\npolicy in scheduler set to %d\n",policy);
+	else
+	cprintf("\npolicy in scheduler set to %d\n",policy);
+
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+/*
+      int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE)
+            count++;
+       }
+
+	cprintf("\nTotal number of processes running: %d\n",count); 
+*/
+
+    ran = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      ran = 1;
+      
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    }
+    release(&ptable.lock);
+
+    if (ran == 0){
+        halt();
+    }
+  }
+}
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state.
+void
+sched(void)
+{
+  int intena;
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(cpu->ncli != 1)
+    panic("sched locks");
+  if(proc->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = cpu->intena;
+  swtch(&proc->context, cpu->scheduler);
+  cpu->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  if (sched_trace_enabled)
+  {
+    cprintf("[%d]", proc->pid);
+  }
+
+  acquire(&ptable.lock);  //DOC: yieldlock
+  proc->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot 
+    // be run from main().
+    first = 0;
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+  
+  // Return to "caller", actually trapret (see allocproc).
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  if(proc == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+
+  // Go to sleep.
+  proc->chan = chan;
+  proc->state = SLEEPING;
+  sched();
+
+  // Tidy up.
+  proc->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
+}
+
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
+}
+
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//PAGEBREAK: 36
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
diff -uNr cs550-17s-proj1-base/proc.c.save.1 cs550-17s-proj1-working/proc.c.save.1
--- cs550-17s-proj1-base/proc.c.save.1	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/proc.c.save.1	2017-02-21 20:35:55.792816151 -0500
@@ -0,0 +1,570 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+
+int myGlobal;
+
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+int policy;
+static struct proc *initproc;
+int STRIDE_TOTAL_TICKETS = 100;
+int nextpid = 1;
+
+int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
+
+extern void forkret(void);
+extern void trapret(void);
+
+static void wakeup1(void *chan);
+
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  release(&ptable.lock);
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+  
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
+  
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
+
+  return p;
+}
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+  p = allocproc();
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+}
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint sz;
+  
+  sz = proc->sz;
+  if(n > 0){
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  proc->sz = sz;
+  switchuvm(proc);
+  return 0;
+}
+
+/*
+int floor(double x)
+{
+  int val = 0;
+	while(val < x)
+	{
+	 val++
+	}
+
+
+if(val == x)
+	return val;
+else 
+	return (val -1);
+}
+
+*/
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+ 
+  pid = np->pid;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
+  np->pass = 0;
+  release(&ptable.lock);
+
+      acquire(&ptable.lock);
+	int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+
+       }
+     cprintf("\n\ntotal active process at this point: %d\n\n", count);
+
+	int l = 1;
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+	   {
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+		if(p->tickets != 0)	     
+		p->strides = (STRIDE_TOTAL_TICKETS/p->tickets);
+           }
+	else
+	    p->tickets = 0;
+            p->strides = 0;
+             cprintf("\nstate: %d Total number of tickets for %d:%d, %d strides: %d\n",p->state, l,p->pid,p->tickets, p->strides);
+           l++;
+       }
+
+      release(&ptable.lock);
+        //cprintf("\nTotal number of active processes: %d\n",count);
+
+	if(myGlobal == 1)
+	  {
+		proc->state = RUNNING;
+		yield();
+  	  }
+
+  return pid;
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+  struct proc *p;
+  int fd;
+
+  if(proc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(proc->ofile[fd]){
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(proc->cwd);
+  end_op();
+  proc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == proc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  proc->state = ZOMBIE;
+
+/*	cprintf("\n\nAfter Exit\n");
+     acquire(&ptable.lock);
+        int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+             cprintf("\nTotal number of tickets: %d\n",p->tickets);
+       }
+
+      release(&ptable.lock); 
+
+*/
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+  struct proc *p;
+  int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
+
+	if(policy)
+	cprintf("\npolicy in scheduler set to %d\n",policy);
+	else
+	cprintf("\npolicy in scheduler set to %d\n",policy);
+
+  for(;;){
+    // Enable interrupts on this processor.
+    sti();
+
+    // Loop over process table looking for process to run.
+    acquire(&ptable.lock);
+/*
+      int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE)
+            count++;
+       }
+
+	cprintf("\nTotal number of processes running: %d\n",count); 
+*/
+
+    ran = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->state != RUNNABLE)
+        continue;
+
+      ran = 1;
+      
+      // Switch to chosen process.  It is the process's job
+      // to release ptable.lock and then reacquire it
+      // before jumping back to us.
+      proc = p;
+      switchuvm(p);
+      p->state = RUNNING;
+      swtch(&cpu->scheduler, proc->context);
+      switchkvm();
+
+      // Process is done running for now.
+      // It should have changed its p->state before coming back.
+      proc = 0;
+    }
+    release(&ptable.lock);
+
+    if (ran == 0){
+        halt();
+    }
+  }
+}
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state.
+void
+sched(void)
+{
+  int intena;
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(cpu->ncli != 1)
+    panic("sched locks");
+  if(proc->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = cpu->intena;
+  swtch(&proc->context, cpu->scheduler);
+  cpu->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  if (sched_trace_enabled)
+  {
+    cprintf("[%d]", proc->pid);
+  }
+
+  acquire(&ptable.lock);  //DOC: yieldlock
+  proc->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot 
+    // be run from main().
+    first = 0;
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+  
+  // Return to "caller", actually trapret (see allocproc).
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  if(proc == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+
+  // Go to sleep.
+  proc->chan = chan;
+  proc->state = SLEEPING;
+  sched();
+
+  // Tidy up.
+  proc->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
+}
+
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
+}
+
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//PAGEBREAK: 36
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
diff -uNr cs550-17s-proj1-base/proc.c.save.2 cs550-17s-proj1-working/proc.c.save.2
--- cs550-17s-proj1-base/proc.c.save.2	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/proc.c.save.2	2017-02-23 16:53:53.853363057 -0500
@@ -0,0 +1,636 @@
+#include "types.h"
+#include "defs.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "x86.h"
+#include "proc.h"
+#include "spinlock.h"
+
+int policy = 0;
+int myGlobal;
+struct {
+  struct spinlock lock;
+  struct proc proc[NPROC];
+} ptable;
+
+//int policy;
+static struct proc *initproc;
+int STRIDE_TOTAL_TICKETS = 100;
+int nextpid = 1;
+int max = 2000;
+int sched_trace_enabled = 0; // ZYF: for CS550 CPU/process project
+
+extern void forkret(void);
+extern void trapret(void);
+
+
+static void wakeup1(void *chan);
+
+void
+pinit(void)
+{
+  initlock(&ptable.lock, "ptable");
+}
+
+//PAGEBREAK: 32
+// Look in the process table for an UNUSED proc.
+// If found, change state to EMBRYO and initialize
+// state required to run in the kernel.
+// Otherwise return 0.
+static struct proc*
+allocproc(void)
+{
+  struct proc *p;
+  char *sp;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == UNUSED)
+      goto found;
+  release(&ptable.lock);
+  return 0;
+
+found:
+  p->state = EMBRYO;
+  p->pid = nextpid++;
+  release(&ptable.lock);
+
+  // Allocate kernel stack.
+  if((p->kstack = kalloc()) == 0){
+    p->state = UNUSED;
+    return 0;
+  }
+  sp = p->kstack + KSTACKSIZE;
+  
+  // Leave room for trap frame.
+  sp -= sizeof *p->tf;
+  p->tf = (struct trapframe*)sp;
+  
+  // Set up new context to start executing at forkret,
+  // which returns to trapret.
+  sp -= 4;
+  *(uint*)sp = (uint)trapret;
+
+  sp -= sizeof *p->context;
+  p->context = (struct context*)sp;
+  memset(p->context, 0, sizeof *p->context);
+  p->context->eip = (uint)forkret;
+
+  return p;
+}
+
+//PAGEBREAK: 32
+// Set up first user process.
+void
+userinit(void)
+{
+  struct proc *p;
+  extern char _binary_initcode_start[], _binary_initcode_size[];
+  
+  p = allocproc();
+  initproc = p;
+  if((p->pgdir = setupkvm()) == 0)
+    panic("userinit: out of memory?");
+  inituvm(p->pgdir, _binary_initcode_start, (int)_binary_initcode_size);
+  p->sz = PGSIZE;
+  memset(p->tf, 0, sizeof(*p->tf));
+  p->tf->cs = (SEG_UCODE << 3) | DPL_USER;
+  p->tf->ds = (SEG_UDATA << 3) | DPL_USER;
+  p->tf->es = p->tf->ds;
+  p->tf->ss = p->tf->ds;
+  p->tf->eflags = FL_IF;
+  p->tf->esp = PGSIZE;
+  p->tf->eip = 0;  // beginning of initcode.S
+
+  safestrcpy(p->name, "initcode", sizeof(p->name));
+  p->cwd = namei("/");
+
+  p->state = RUNNABLE;
+}
+
+// Grow current process's memory by n bytes.
+// Return 0 on success, -1 on failure.
+int
+growproc(int n)
+{
+  uint sz;
+  
+  sz = proc->sz;
+  if(n > 0){
+    if((sz = allocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  } else if(n < 0){
+    if((sz = deallocuvm(proc->pgdir, sz, sz + n)) == 0)
+      return -1;
+  }
+  proc->sz = sz;
+  switchuvm(proc);
+  return 0;
+}
+
+
+// Create a new process copying p as the parent.
+// Sets up stack to return as if from system call.
+// Caller must set state of returned proc to RUNNABLE.
+
+int
+fork(void)
+{
+  int i, pid;
+  struct proc *np;
+  struct proc *p;
+
+  // Allocate process.
+  if((np = allocproc()) == 0)
+    return -1;
+
+  // Copy process state from p.
+  if((np->pgdir = copyuvm(proc->pgdir, proc->sz)) == 0){
+    kfree(np->kstack);
+    np->kstack = 0;
+    np->state = UNUSED;
+    return -1;
+  }
+  np->sz = proc->sz;
+  np->parent = proc;
+  *np->tf = *proc->tf;
+
+  // Clear %eax so that fork returns 0 in the child.
+  np->tf->eax = 0;
+ 
+
+  for(i = 0; i < NOFILE; i++)
+    if(proc->ofile[i])
+      np->ofile[i] = filedup(proc->ofile[i]);
+  np->cwd = idup(proc->cwd);
+
+  safestrcpy(np->name, proc->name, sizeof(proc->name));
+ 
+  pid = np->pid;
+  np->pass = 0;
+
+  // lock to force the compiler to emit the np->state write last.
+  acquire(&ptable.lock);
+  np->state = RUNNABLE;
+  release(&ptable.lock);
+
+      acquire(&ptable.lock);
+	int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+
+       }
+     cprintf("\n\ntotal active process at this point: %d\n\n", count);
+
+        int l = 1;
+	for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+	   {
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+		if(p->tickets != 0)
+		p->strides = (STRIDE_TOTAL_TICKETS/p->tickets);
+           }
+	else{
+	    p->tickets = 0;
+            p->strides = 0;}
+            cprintf("\nstate: %d Total number of tickets for %d:%d, %d strides: %d pass: %d\n",p->state, l,p->pid,p->tickets, p->strides, p->pass);
+            l++;
+       }
+
+        release(&ptable.lock);
+        //cprintf("\nTotal number of active processes: %d\n",count);
+
+	if(myGlobal == 1)
+	  {
+		proc->state = RUNNING;
+		yield();
+  	  }
+
+  return pid;
+}
+
+// Exit the current process.  Does not return.
+// An exited process remains in the zombie state
+// until its parent calls wait() to find out it exited.
+void
+exit(void)
+{
+  struct proc *p;
+  int fd;
+
+  if(proc == initproc)
+    panic("init exiting");
+
+  // Close all open files.
+  for(fd = 0; fd < NOFILE; fd++){
+    if(proc->ofile[fd]){
+      fileclose(proc->ofile[fd]);
+      proc->ofile[fd] = 0;
+    }
+  }
+
+  begin_op();
+  iput(proc->cwd);
+  end_op();
+  proc->cwd = 0;
+
+  acquire(&ptable.lock);
+
+  // Parent might be sleeping in wait().
+  wakeup1(proc->parent);
+
+  // Pass abandoned children to init.
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->parent == proc){
+      p->parent = initproc;
+      if(p->state == ZOMBIE)
+        wakeup1(initproc);
+    }
+  }
+
+  // Jump into the scheduler, never to return.
+  proc->state = ZOMBIE;
+
+/*	cprintf("\n\nAfter Exit\n");
+     acquire(&ptable.lock);
+        int count = 0;
+      for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+            count++;
+       }
+
+        for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+         if(p->state == RUNNABLE || p->state == RUNNING)
+             p->tickets = (STRIDE_TOTAL_TICKETS/count);
+             cprintf("\nTotal number of tickets: %d\n",p->tickets);
+       }
+
+      release(&ptable.lock); 
+
+*/
+  sched();
+  panic("zombie exit");
+}
+
+// Wait for a child process to exit and return its pid.
+// Return -1 if this process has no children.
+int
+wait(void)
+{
+  struct proc *p;
+  int havekids, pid;
+
+  acquire(&ptable.lock);
+  for(;;){
+    // Scan through table looking for zombie children.
+    havekids = 0;
+    for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+      if(p->parent != proc)
+        continue;
+      havekids = 1;
+      if(p->state == ZOMBIE){
+        // Found one.
+        pid = p->pid;
+        kfree(p->kstack);
+        p->kstack = 0;
+        freevm(p->pgdir);
+        p->state = UNUSED;
+        p->pid = 0;
+        p->parent = 0;
+        p->name[0] = 0;
+        p->killed = 0;
+        release(&ptable.lock);
+        return pid;
+      }
+    }
+
+    // No point waiting if we don't have any children.
+    if(!havekids || proc->killed){
+      release(&ptable.lock);
+      return -1;
+    }
+
+    // Wait for children to exit.  (See wakeup1 call in proc_exit.)
+    sleep(proc, &ptable.lock);  //DOC: wait-sleep
+  }
+}
+
+//PAGEBREAK: 42
+// Per-CPU process scheduler.
+// Each CPU calls scheduler() after setting itself up.
+// Scheduler never returns.  It loops, doing:
+//  - choose a process to run
+//  - swtch to start running that process
+//  - eventually that process transfers control
+//      via swtch back to the scheduler.
+void
+scheduler(void)
+{
+    struct proc *p;
+struct proc *q;
+    struct proc *minProc;
+   // double z;
+    int ran = 0; // CS550: to solve the 100%-CPU-utilization-when-idling problem
+
+    for(;;)
+    {
+        // Enable interrupts on this processor.
+        sti();
+
+        // Loop over process table looking for process to run.
+        acquire(&ptable.lock);
+
+        if(policy == 1)
+        {
+            int  minpass = max;
+            //find the min pass
+            ran = 0;
+
+
+for(q = ptable.proc; q < &ptable.proc[NPROC]; q++)
+{
+        if(q->pid == 3)
+        cprintf("\n%d:%d\n", p->pid,p->pass);
+}
+
+for(q = ptable.proc; q < &ptable.proc[NPROC]; q++)
+{
+        if(q->pid == 4
+
+
+
+            for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+            {
+
+        cprintf("\n%d:%d\n", p->pid,p->pass);
+}
+
+
+
+
+            for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+            {
+                if(p->state != RUNNABLE)
+		  continue;
+		if(p->pass < minpass)
+			{
+			 minpass = p->pass;
+			 minProc= p;
+			}
+            }
+         if(minpass >= max)
+           {
+                for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+                p->pass = 0; 
+           }
+            // obtain the process to be scheduled
+                p= minProc;
+                p->pass = p->pass + p->strides;
+                ran = 1;
+                proc = p;
+                switchuvm(p);
+                p->state = RUNNING;
+                swtch(&cpu->scheduler, proc->context);
+                switchkvm();
+
+                // Process is done running for now.
+                // It should have changed its p->state before coming back.
+                proc = 0;
+        }
+        else
+        {
+            ran = 0;
+            for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+            {
+                if(p->state != RUNNABLE)
+                    continue;
+
+                ran = 1;
+
+                // Switch to chosen process.  It is the process's job
+                // to release ptable.lock and then reacquire it
+                // before jumping back to us.
+       //   cprintf("chosen process:%d",p->pid);
+                proc = p;
+                switchuvm(p);
+                p->state = RUNNING;
+                swtch(&cpu->scheduler, proc->context);
+                switchkvm();
+
+                // Process is done running for now.
+                // It should have changed its p->state before coming back.
+                proc = 0;
+            }
+        }
+        release(&ptable.lock);
+
+        if (ran == 0)
+        {
+            halt();
+        }
+//for(z=0;z<10000000;z++)
+//{if(z>100) z = z - 0.5;}
+    }
+}
+
+
+// Enter scheduler.  Must hold only ptable.lock
+// and have changed proc->state.
+void
+sched(void)
+{
+  int intena;
+
+  if(!holding(&ptable.lock))
+    panic("sched ptable.lock");
+  if(cpu->ncli != 1)
+    panic("sched locks");
+  if(proc->state == RUNNING)
+    panic("sched running");
+  if(readeflags()&FL_IF)
+    panic("sched interruptible");
+  intena = cpu->intena;
+  swtch(&proc->context, cpu->scheduler);
+  cpu->intena = intena;
+}
+
+// Give up the CPU for one scheduling round.
+void
+yield(void)
+{
+  if (sched_trace_enabled)
+  {
+    cprintf("[%d]-%d,", proc->pid, proc->pass);
+  }
+
+  acquire(&ptable.lock);  //DOC: yieldlock
+  proc->state = RUNNABLE;
+  sched();
+  release(&ptable.lock);
+}
+
+// A fork child's very first scheduling by scheduler()
+// will swtch here.  "Return" to user space.
+void
+forkret(void)
+{
+  static int first = 1;
+  // Still holding ptable.lock from scheduler.
+  release(&ptable.lock);
+
+  if (first) {
+    // Some initialization functions must be run in the context
+    // of a regular process (e.g., they call sleep), and thus cannot 
+    // be run from main().
+    first = 0;
+    iinit(ROOTDEV);
+    initlog(ROOTDEV);
+  }
+  
+  // Return to "caller", actually trapret (see allocproc).
+}
+
+// Atomically release lock and sleep on chan.
+// Reacquires lock when awakened.
+void
+sleep(void *chan, struct spinlock *lk)
+{
+  if(proc == 0)
+    panic("sleep");
+
+  if(lk == 0)
+    panic("sleep without lk");
+
+  // Must acquire ptable.lock in order to
+  // change p->state and then call sched.
+  // Once we hold ptable.lock, we can be
+  // guaranteed that we won't miss any wakeup
+  // (wakeup runs with ptable.lock locked),
+  // so it's okay to release lk.
+  if(lk != &ptable.lock){  //DOC: sleeplock0
+    acquire(&ptable.lock);  //DOC: sleeplock1
+    release(lk);
+  }
+
+  // Go to sleep.
+  proc->chan = chan;
+  proc->state = SLEEPING;
+  sched();
+
+  // Tidy up.
+  proc->chan = 0;
+
+  // Reacquire original lock.
+  if(lk != &ptable.lock){  //DOC: sleeplock2
+    release(&ptable.lock);
+    acquire(lk);
+  }
+}
+
+//PAGEBREAK!
+// Wake up all processes sleeping on chan.
+// The ptable lock must be held.
+static void
+wakeup1(void *chan)
+{
+  struct proc *p;
+
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+    if(p->state == SLEEPING && p->chan == chan)
+      p->state = RUNNABLE;
+}
+
+// Wake up all processes sleeping on chan.
+void
+wakeup(void *chan)
+{
+  acquire(&ptable.lock);
+  wakeup1(chan);
+  release(&ptable.lock);
+}
+
+// Kill the process with the given pid.
+// Process won't exit until it returns
+// to user space (see trap in trap.c).
+int
+kill(int pid)
+{
+  struct proc *p;
+
+  acquire(&ptable.lock);
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->pid == pid){
+      p->killed = 1;
+      // Wake process from sleep if necessary.
+      if(p->state == SLEEPING)
+        p->state = RUNNABLE;
+      release(&ptable.lock);
+      return 0;
+    }
+  }
+  release(&ptable.lock);
+  return -1;
+}
+
+//PAGEBREAK: 36
+// Print a process listing to console.  For debugging.
+// Runs when user types ^P on console.
+// No lock to avoid wedging a stuck machine further.
+void
+procdump(void)
+{
+  static char *states[] = {
+  [UNUSED]    "unused",
+  [EMBRYO]    "embryo",
+  [SLEEPING]  "sleep ",
+  [RUNNABLE]  "runble",
+  [RUNNING]   "run   ",
+  [ZOMBIE]    "zombie"
+  };
+  int i;
+  struct proc *p;
+  char *state;
+  uint pc[10];
+  
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++){
+    if(p->state == UNUSED)
+      continue;
+    if(p->state >= 0 && p->state < NELEM(states) && states[p->state])
+      state = states[p->state];
+    else
+      state = "???";
+    cprintf("%d %s %s", p->pid, state, p->name);
+    if(p->state == SLEEPING){
+      getcallerpcs((uint*)p->context->ebp+2, pc);
+      for(i=0; i<10 && pc[i] != 0; i++)
+        cprintf(" %p", pc[i]);
+    }
+    cprintf("\n");
+  }
+}
+
+int transfer_tickets(int pid, int tickets, struct proc *calle)
+{
+ struct proc *p;
+ acquire(&ptable.lock);
+//cprintf("in function transfer_tickets: pid: %d, tickets: %d, callepid: %d", pid, tickets, calle->pid);
+ 
+  for(p = ptable.proc; p < &ptable.proc[NPROC]; p++)
+   {
+     // cprintf("\npid: %d\n", p->pid);
+      if(p->pid == pid)
+       {
+        // cprintf("\npid: %d\n", p->pid);
+         p->tickets += tickets;
+	 calle->tickets -= tickets;
+	 release(&ptable.lock);
+         return calle->tickets;
+       }
+   }
+ 
+ release(&ptable.lock);
+ return -3;
+
+}
diff -uNr cs550-17s-proj1-base/proc.h cs550-17s-proj1-working/proc.h
--- cs550-17s-proj1-base/proc.h	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/proc.h	2017-02-22 18:25:51.091271946 -0500
@@ -1,6 +1,8 @@
 // Segments in proc->gdt.
 #define NSEGS     7
 
+extern int myGlobal;
+
 // Per-CPU state
 struct cpu {
   uchar id;                    // Local APIC ID; index into cpus[] below
@@ -18,6 +20,8 @@
 
 extern struct cpu cpus[NCPU];
 extern int ncpu;
+extern int policy;
+extern int transfer_tickets(int pid, int tickets, struct proc *calle);
 
 // Per-CPU variables, holding pointers to the
 // current cpu and to the current process.
@@ -49,7 +53,7 @@
   uint eip;
 };
 
-enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE};
 
 // Per-process state
 struct proc {
@@ -66,6 +70,9 @@
   struct file *ofile[NOFILE];  // Open files
   struct inode *cwd;           // Current directory
   char name[16];               // Process name (debugging)
+  int tickets;
+  int strides;
+  int pass;
 };
 
 // Process memory is laid out contiguously, low addresses first:
diff -uNr cs550-17s-proj1-base/proc.h.save.1 cs550-17s-proj1-working/proc.h.save.1
--- cs550-17s-proj1-base/proc.h.save.1	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/proc.h.save.1	2017-02-22 18:13:04.370830879 -0500
@@ -0,0 +1,82 @@
+// Segments in proc->gdt.
+#define NSEGS     7
+
+extern int myGlobal;
+
+// Per-CPU state
+struct cpu {
+  uchar id;                    // Local APIC ID; index into cpus[] below
+  struct context *scheduler;   // swtch() here to enter scheduler
+  struct taskstate ts;         // Used by x86 to find stack for interrupt
+  struct segdesc gdt[NSEGS];   // x86 global descriptor table
+  volatile uint started;       // Has the CPU started?
+  int ncli;                    // Depth of pushcli nesting.
+  int intena;                  // Were interrupts enabled before pushcli?
+  
+  // Cpu-local storage variables; see below
+  struct cpu *cpu;
+  struct proc *proc;           // The currently-running process.
+};
+
+extern struct cpu cpus[NCPU];
+extern int ncpu;
+extern int policy;
+int sys_transfer_(void);
+
+// Per-CPU variables, holding pointers to the
+// current cpu and to the current process.
+// The asm suffix tells gcc to use "%gs:0" to refer to cpu
+// and "%gs:4" to refer to proc.  seginit sets up the
+// %gs segment register so that %gs refers to the memory
+// holding those two variables in the local cpu's struct cpu.
+// This is similar to how thread-local variables are implemented
+// in thread libraries such as Linux pthreads.
+extern struct cpu *cpu asm("%gs:0");       // &cpus[cpunum()]
+extern struct proc *proc asm("%gs:4");     // cpus[cpunum()].proc
+
+//PAGEBREAK: 17
+// Saved registers for kernel context switches.
+// Don't need to save all the segment registers (%cs, etc),
+// because they are constant across kernel contexts.
+// Don't need to save %eax, %ecx, %edx, because the
+// x86 convention is that the caller has saved them.
+// Contexts are stored at the bottom of the stack they
+// describe; the stack pointer is the address of the context.
+// The layout of the context matches the layout of the stack in swtch.S
+// at the "Switch stacks" comment. Switch doesn't save eip explicitly,
+// but it is on the stack and allocproc() manipulates it.
+struct context {
+  uint edi;
+  uint esi;
+  uint ebx;
+  uint ebp;
+  uint eip;
+};
+
+enum procstate { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE};
+
+// Per-process state
+struct proc {
+  uint sz;                     // Size of process memory (bytes)
+  pde_t* pgdir;                // Page table
+  char *kstack;                // Bottom of kernel stack for this process
+  enum procstate state;        // Process state
+  int pid;                     // Process ID
+  struct proc *parent;         // Parent process
+  struct trapframe *tf;        // Trap frame for current syscall
+  struct context *context;     // swtch() here to run process
+  void *chan;                  // If non-zero, sleeping on chan
+  int killed;                  // If non-zero, have been killed
+  struct file *ofile[NOFILE];  // Open files
+  struct inode *cwd;           // Current directory
+  char name[16];               // Process name (debugging)
+  int tickets;
+  int strides;
+  int pass;
+};
+
+// Process memory is laid out contiguously, low addresses first:
+//   text
+//   original data and bss
+//   fixed-size stack
+//   expandable heap
diff -uNr cs550-17s-proj1-base/proj1_forktest.c cs550-17s-proj1-working/proj1_forktest.c
--- cs550-17s-proj1-base/proj1_forktest.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/proj1_forktest.c	2017-02-19 18:33:25.586101421 -0500
@@ -5,10 +5,10 @@
    stub functions for the system call user space wrapper functions are provided. 
    REMEMBER to disable the stub functions (by commenting the following macro) to 
    allow your implementation to work properly. */
-#define STUB_FUNCS
-#ifdef STUB_FUNCS
-void fork_winner(int winner) {}
-#endif
+//#define STUB_FUNCS
+//#ifdef STUB_FUNCS
+//void fork_winner(int winner) {}
+//#endif
 
 
 #define TOTAL_TEST_TRIALS 50
@@ -41,6 +41,7 @@
 
     fork_winner(w); // set according to user input
 
+    printf(1, "\n\n\n");
     printf(1, "\nCS550 proj1 fork test ==> \n");
     
     for (i = 0; i < TOTAL_TEST_TRIALS; i++)
diff -uNr cs550-17s-proj1-base/proj1_schdtest.c cs550-17s-proj1-working/proj1_schdtest.c
--- cs550-17s-proj1-base/proj1_schdtest.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/proj1_schdtest.c	2017-02-23 19:23:52.250076710 -0500
@@ -1,7 +1,9 @@
 #include "types.h"
 #include "user.h"
 
-#define LOOP_CNT 0x01000000
+#define LOOP_CNT 0x02000000
+
+int pid = 0;
 
 void do_child(void)
 {
@@ -13,14 +15,14 @@
         tmp += cnt;
         cnt ++;
     }
-
     exit();
 }
 
 
 void do_parent(void)
 {
-    int cnt = 0;
+
+  int cnt = 0;
     int tmp = 0;
 
     while(cnt < LOOP_CNT)
@@ -32,8 +34,6 @@
 
 void example_test_code()
 {
-    int pid = 0;
-
     pid = fork();
     if (pid < 0)
     {
@@ -63,8 +63,8 @@
 
     /* ---------------- start: add your test code ------------------- */
 
-    example_test_code();
-
+        set_sched(1);
+        example_test_code();
     /* ---------------- end: add your test code ------------------- */
 
     enable_sched_trace(0);
diff -uNr cs550-17s-proj1-base/shutdown.c cs550-17s-proj1-working/shutdown.c
--- cs550-17s-proj1-base/shutdown.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/shutdown.c	2017-02-19 02:18:14.168565026 -0500
@@ -1,15 +1,15 @@
 #include "types.h"
 #include "stat.h"
 #include "user.h"
-
+//#include <stdlib.h>
 /* CS550 ATTENTION: to ensure correct compilation of the base code, 
    stub functions for the system call user space wrapper functions are provided. 
    REMEMBER to disable the stub functions (by commenting the following macro) to 
    allow your implementation to work properly. */
-#define STUB_FUNCS
-#ifdef STUB_FUNCS
-void shutdown(void) {}
-#endif
+//#define STUB_FUNCS
+//#ifdef STUB_FUNCS
+//void shutdown(void) {}
+//#endif
 
 
 int 
@@ -17,5 +17,6 @@
 {
     printf(1, "BYE~\n");
     shutdown();
-    exit(); //return 0;
+    exit(); 
+   // return 0;
 }
diff -uNr cs550-17s-proj1-base/syscall.c cs550-17s-proj1-working/syscall.c
--- cs550-17s-proj1-base/syscall.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/syscall.c	2017-02-22 17:15:02.742108301 -0500
@@ -99,7 +99,11 @@
 extern int sys_write(void);
 extern int sys_uptime(void);
 extern int sys_enable_sched_trace(void);
-
+extern int sys_shutdown(void);
+extern int sys_fork_winner(void);
+extern int sys_set_sched(void);
+extern int sys_tickets_owned(void);
+extern int sys_transfer_tickets(void);
 
 static int (*syscalls[])(void) = {
 [SYS_fork]    sys_fork,
@@ -124,7 +128,11 @@
 [SYS_mkdir]   sys_mkdir,
 [SYS_close]   sys_close,
 [SYS_enable_sched_trace]   sys_enable_sched_trace,
-
+[SYS_shutdown] sys_shutdown,
+[SYS_fork_winner] sys_fork_winner,
+[SYS_set_sched] sys_set_sched,
+[SYS_tickets_owned] sys_tickets_owned,
+[SYS_transfer_tickets] sys_transfer_tickets,
 };
 
 void
diff -uNr cs550-17s-proj1-base/syscall.h cs550-17s-proj1-working/syscall.h
--- cs550-17s-proj1-base/syscall.h	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/syscall.h	2017-02-22 17:13:30.856005214 -0500
@@ -21,4 +21,9 @@
 #define SYS_mkdir  20
 #define SYS_close  21
 #define SYS_enable_sched_trace  22
+#define SYS_shutdown  23
+#define SYS_fork_winner 24
+#define SYS_set_sched 25
+#define SYS_tickets_owned 26
+#define SYS_transfer_tickets 27
 
diff -uNr cs550-17s-proj1-base/sysproc.c cs550-17s-proj1-working/sysproc.c
--- cs550-17s-proj1-base/sysproc.c	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/sysproc.c	2017-02-23 19:25:24.052309841 -0500
@@ -90,6 +90,58 @@
   return xticks;
 }
 
+int sys_shutdown(void)
+{
+ // cprintf("shutdown signal sent\n");
+  outw( 0xB004, 0x0  | 0x2000 );
+
+  return 0;
+}
+
+int sys_fork_winner(void)
+{
+  int n;
+  if(!argint(0,&n))
+    {
+	if(n ==1)
+	  myGlobal = 1;
+	  //cprintf("\nsetting myGlobal to 1\n");
+	else
+	 myGlobal = 0;
+	 //cprintf("\nsetting myGlobal to 0\n"); 
+    }
+//  get_random_bytes(&i, sizeof(int));
+//  cprintf("\n%d\n",1);
+  return 0;
+}
+
+
+int sys_set_sched(void)
+{
+ int m;
+ if(!argint(0,&m))
+  {
+	//cprintf("\n\ninside method value of m: %d",m );
+	if(m)
+	  policy = 1;  //use stride scheduling
+  }
+	return 0;
+}
+
+int
+sys_tickets_owned(void)
+{
+  return proc->tickets;
+}
+
+int sys_transfer_tickets(void)
+{
+ int pid, tickets;
+ argint(0, &pid);
+ argint(1, &tickets);
+ return transfer_tickets(pid, tickets, proc);
+}
+
 extern int sched_trace_enabled;
 int sys_enable_sched_trace(void)
 {
diff -uNr cs550-17s-proj1-base/sysproc.c.save.1 cs550-17s-proj1-working/sysproc.c.save.1
--- cs550-17s-proj1-base/sysproc.c.save.1	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/sysproc.c.save.1	2017-02-19 15:39:00.515943521 -0500
@@ -0,0 +1,117 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+int
+sys_fork(void)
+{
+  return fork();
+}
+
+int
+sys_exit(void)
+{
+  exit();
+  return 0;  // not reached
+}
+
+int
+sys_wait(void)
+{
+  return wait();
+}
+
+int
+sys_kill(void)
+{
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
+}
+
+int
+sys_getpid(void)
+{
+  return proc->pid;
+}
+
+int
+sys_sbrk(void)
+{
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  addr = proc->sz;
+  if(growproc(n) < 0)
+    return -1;
+  return addr;
+}
+
+int
+sys_sleep(void)
+{
+  int n;
+  uint ticks0;
+  
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+    if(proc->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+  return 0;
+}
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+  uint xticks;
+  
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+int sys_shutdown(void)
+{
+ // cprintf("shutdown signal sent\n");
+  outw( 0xB004, 0x0  | 0x2000 );
+
+  return 0;
+}
+
+int sys_fork_winner(void)
+{
+  
+  return 0;
+}
+
+
+extern int sched_trace_enabled;
+int sys_enable_sched_trace(void)
+{
+  if (argint(0, &sched_trace_enabled) < 0)
+  {
+    cprintf("enable_sched_trace() failed!\n");
+  }
+
+  return 0;
+}
diff -uNr cs550-17s-proj1-base/sysproc.c.save.2 cs550-17s-proj1-working/sysproc.c.save.2
--- cs550-17s-proj1-base/sysproc.c.save.2	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/sysproc.c.save.2	2017-02-19 20:00:46.978900382 -0500
@@ -0,0 +1,110 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+int
+sys_fork(void)
+{
+  return fork();
+}
+
+int
+sys_exit(void)
+{
+  exit();
+  return 0;  // not reached
+}
+
+int
+sys_wait(void)
+{
+  return wait();
+}
+
+int
+sys_kill(void)
+{
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
+}
+
+int
+sys_getpid(void)
+{
+  return proc->pid;
+}
+
+int
+sys_sbrk(void)
+{
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  addr = proc->sz;
+  if(growproc(n) < 0)
+    return -1;
+  return addr;
+}
+
+int
+sys_sleep(void)
+{
+  int n;
+  uint ticks0;
+  
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+    if(proc->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+  return 0;
+}
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+  uint xticks;
+  
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+int sys_shutdown(void)
+{
+  cprintf("shutdown signal sent\n");
+  outw( 0xB004, 0x0  | 0x2000 );
+
+  return 0;
+}
+
+ int sched_trace_enabled;
+int sys_enable_sched_trace(void)
+{
+  if (argint(0, &sched_trace_enabled) < 0)
+  {
+    cprintf("enable_sched_trace() failed!\n");
+  }
+
+  return 0;
+}
diff -uNr cs550-17s-proj1-base/sysproc.c.save.3 cs550-17s-proj1-working/sysproc.c.save.3
--- cs550-17s-proj1-base/sysproc.c.save.3	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/sysproc.c.save.3	2017-02-19 23:01:12.406615499 -0500
@@ -0,0 +1,117 @@
+#include "types.h"
+#include "x86.h"
+#include "defs.h"
+#include "date.h"
+#include "param.h"
+#include "memlayout.h"
+#include "mmu.h"
+#include "proc.h"
+
+int
+sys_fork(void)
+{
+  return fork();
+}
+
+int
+sys_exit(void)
+{
+  exit();
+  return 0;  // not reached
+}
+
+int
+sys_wait(void)
+{
+  return wait();
+}
+
+int
+sys_kill(void)
+{
+  int pid;
+
+  if(argint(0, &pid) < 0)
+    return -1;
+  return kill(pid);
+}
+
+int
+sys_getpid(void)
+{
+  return proc->pid;
+}
+
+int
+sys_sbrk(void)
+{
+  int addr;
+  int n;
+
+  if(argint(0, &n) < 0)
+    return -1;
+  addr = proc->sz;
+  if(growproc(n) < 0)
+    return -1;
+  return addr;
+}
+
+int
+sys_sleep(void)
+{
+  int n;
+  uint ticks0;
+  
+  if(argint(0, &n) < 0)
+    return -1;
+  acquire(&tickslock);
+  ticks0 = ticks;
+  while(ticks - ticks0 < n){
+    if(proc->killed){
+      release(&tickslock);
+      return -1;
+    }
+    sleep(&ticks, &tickslock);
+  }
+  release(&tickslock);
+  return 0;
+}
+
+// return how many clock tick interrupts have occurred
+// since start.
+int
+sys_uptime(void)
+{
+  uint xticks;
+  
+  acquire(&tickslock);
+  xticks = ticks;
+  release(&tickslock);
+  return xticks;
+}
+
+int sys_shutdown(void)
+{
+  cp cprintf("shutdown signal sent\n");rintf("shutdown signal sent\n");
+  outw( 0xB004, 0x0  | 0x2000 );
+
+  return 0;
+}
+
+int sys_fork_winner(void)
+{
+	
+
+
+}
+
+extern int sched_trace_enabled;
+int sys_enable_sched_trace(void)
+{
+  if (argint(0, &sched_trace_enabled) < 0)
+  {
+    cprintf("enable_sched_trace() failed!\n");
+  }
+
+  return 0;
+}
diff -uNr cs550-17s-proj1-base/user.h cs550-17s-proj1-working/user.h
--- cs550-17s-proj1-base/user.h	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/user.h	2017-02-22 17:11:04.007037188 -0500
@@ -23,6 +23,7 @@
 char* sbrk(int);
 int sleep(int);
 int uptime(void);
+int tickets_owned(void);
 
 // ulib.c
 int stat(char*, struct stat*);
@@ -39,3 +40,7 @@
 int atoi(const char*);
 
 void enable_sched_trace(int enable);
+void shutdown(void);
+void fork_winner(int winner);
+void set_sched(int);
+int transfer_tickets(int pid, int tickets);
diff -uNr cs550-17s-proj1-base/usys.S cs550-17s-proj1-working/usys.S
--- cs550-17s-proj1-base/usys.S	2017-02-12 20:27:09.000000000 -0500
+++ cs550-17s-proj1-working/usys.S	2017-02-22 17:12:37.581104924 -0500
@@ -30,3 +30,8 @@
 SYSCALL(sleep)
 SYSCALL(uptime)
 SYSCALL(enable_sched_trace)
+SYSCALL(shutdown)
+SYSCALL(fork_winner)
+SYSCALL(set_sched)
+SYSCALL(tickets_owned)
+SYSCALL(transfer_tickets)
diff -uNr cs550-17s-proj1-base/xv6-cs550-Makefile.patch cs550-17s-proj1-working/xv6-cs550-Makefile.patch
--- cs550-17s-proj1-base/xv6-cs550-Makefile.patch	1969-12-31 19:00:00.000000000 -0500
+++ cs550-17s-proj1-working/xv6-cs550-Makefile.patch	2017-02-18 23:47:05.000000000 -0500
@@ -0,0 +1,11 @@
+--- base/Makefile	2017-01-26 15:56:38.358804433 -0500
++++ working/Makefile	2017-01-26 15:58:34.972234507 -0500
+@@ -51,7 +51,7 @@
+ endif
+ 
+ # If the makefile can't find QEMU, specify its path here
+-# QEMU = qemu-system-i386
++QEMU = ~zhangy/fs/bin/qemu-system-i386
+ 
+ # Try to infer the correct QEMU
+ ifndef QEMU
